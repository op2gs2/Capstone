import hashlib
import os

import pefile
from tensorflow import keras

from PIL import Image
import numpy as np
import imageio
import array

import urllib
import json
import time

import glob
import mysql.connector
import boto3

class malware_analysis_server:
    def __init__(self):
        print("0. init")
        self.file = b'00' # 파일의 바이너리 데이터
        self.file_name = '' # SHA256으로 추출한 파일 이름
        self.image_name = '' # 파일을 이미지화한 파일 이름
        self.pe_values = []
        self.cnn_probability = float(0.0) # CNN의 결과
        self.virustotal_result = []
        self.file_path = r""

    # 파일 입력 받기
    def input_file(self):
        # S3 접속을 위한 정보
        AWS_ACCESS_KEY_ID = ""
        AWS_SECRET_ACCESS_KEY = ""
        AWS_DEFAULT_REGION = ""
        bucket_name = ""
        # s3 접속 설정
        try:
            s3 = boto3.client('s3',
                          aws_access_key_id=AWS_ACCESS_KEY_ID,
                          aws_secret_access_key=AWS_SECRET_ACCESS_KEY,
                          region_name=AWS_DEFAULT_REGION
                          )
        except:
            raise ConnectionError("Fail to established S3 Connection")

        # 파일 이름을 가져오기
        try:
            file_list = s3.list_objects(Bucket = bucket_name)
            self.file_name = file_list.get('Contents')[0].get('Key')
        except:
            raise Exception("Fail to bring file name")

        # 파일을 다운 받기
        with open('Temp'+self.file_name, 'wb') as f:
            s3.download_fileobj(bucket_name, self.file_name, f) # 파일을 다운 받기
        f.close()

        with open('Temp'+self.file_name, 'rb') as f:
            self.file = f.read()
            self.file_path = './Temp'+self.file_name
        f.close()


        # 처리한 파일은 서버에서 삭제하기
        s3 = boto3.resource('s3',
                            aws_access_key_id=AWS_ACCESS_KEY_ID,
                            aws_secret_access_key=AWS_SECRET_ACCESS_KEY,
                            region_name=AWS_DEFAULT_REGION
                            )
        s3.Object(bucket_name, self.file_name).delete()

        print("1. Input File Complete")

    # PE 여부 검사
    def PE_check(self):
        if self.file[0:2] != b'MZ':
            raise Exception("This is not a PE file.")

        print("2. PE file check complete!!")

    # SHA-256 이름 검출
    def get_sha256_value(self):
        self.image_name = hashlib.sha256(self.file).hexdigest()

        print("3. Getting PE file sha256 value complete!!")

    # PE 특징 검출
    def Extract_PE_Header(self):
        pe = pefile.PE(self.file_path)
	
	# FileHeader 값 추출
        NT_Header_File_Header = [
            pe.FILE_HEADER.Machine,
            pe.FILE_HEADER.NumberOfSections
        ]

	# OptionalHeader 값 추출
        NT_Header_Optional_Header = [
            pe.OPTIONAL_HEADER.AddressOfEntryPoint,
            pe.OPTIONAL_HEADER.ImageBase,
            pe.OPTIONAL_HEADER.FileAlignment,
            pe.OPTIONAL_HEADER.SizeOfImage,
            pe.OPTIONAL_HEADER.SizeOfHeaders
        ]
	
	# SectionHeader 값 추출
        Section_Header = []
        for section in pe.sections:
            Section_Header.append(section.Name)
            Section_Header.append(hex(section.Misc_VirtualSize))
            Section_Header.append(hex(section.VirtualAddress))
            Section_Header.append(hex(section.SizeOfRawData))
            Section_Header.append(hex(section.PointerToRawData))
            break

        self.pe_values.append(NT_Header_File_Header) # self.pe_values[0]
        self.pe_values.append(NT_Header_Optional_Header) # self.pe_values[1]
        self.pe_values.append(Section_Header) # self.pe_values[2]

        print("4. Getting PE file value complete!!")

    # 이미지 추출하기
    def Extract_Image(self):
        file_length = len(self.file)

        width = int(file_length ** 0.05)  # 파일 길이의 제곱근을 구함(정사각형 모양 이미지 구현을 위해)
        rem = file_length % width

        with open(self.file_path,"rb") as f:
            a = array.array("B")  # uint8 배열을 선언
            a.fromfile(f, file_length - rem)  # 파일 객체의 내용을 지정된 수만큼 읽어들임 (파일의 바이너리로 배열을 구성)

        g = np.reshape(a, (int(len(a) / width), width))  # 배열의 모양을 정사각형으로 재조정
        g = np.uint8(g)  # g np배열을 uint8형으로 형변환

        # 이미지가 저장될 경로를 지정
        fpng = "./" + self.image_name + ".png" # 아마존 경로 추가
        imageio.imwrite(fpng, g)  # [수정사항] scipy.misc.imsave(fpng, g) 대신 사용

        outfile = "./" + self.image_name + "_thumb.png" # 아마존 경로 추가
        size = 128, 128

        if fpng != outfile:
            im = Image.open(fpng)
            im.thumbnail(size, Image.ANTIALIAS)  # 이미지를 256x256 크기의 썸네일로 생성
            im.save(outfile, "PNG")

        print("5. Extract Image file complete!!")

    # CNN 예측하기
    def do_CNN(self):
        image_path = "./" + self.image_name + "_thumb.png"
        sample = np.zeros((1,128,128,1))
        # 이미지 불러 들이기
        img = Image.open(image_path).convert("L")
        out = img.resize((128,128))
        sample[0,:,:,0] = out
        # CNN 모델을 이용해 예측하기
        model = keras.models.load_model(r'D:/OneDrive - 한림대학교/바탕 화면/Working Space/Capstone/src/1. 악성코드 수집/best-cnn-model.h5')
        self.cnn_probability = model.predict(sample)
        print("probability of", image_path, "is", self.cnn_probability)

        print("6. Prediction using CNN is complete!!")

    # VirusTotal API 불러오기
    def VirusTotal_Scan(self):
        api = 'dbae55ce231bd44e635b5310d293fa247b2c98c8ee5664b8100a3fb65b035fb6'
        base = 'https://www.virustotal.com/vtapi/v2/'

        def get_report(sha256):
            param = {'resource': self.image_name, 'apikey': api, 'allinfo': '1'}
            url = base + "file/report"
            data = urllib.parse.urlencode(param)  # Python 3에는 urllib가 나뉘어져 있음 (parse, request)
            data = data.encode('utf-8')  # urlopen()에 data를 넣기 위해, 인코딩이 되어 있어야 함.
            result = urllib.request.urlopen(url, data)

            jdata = json.loads(result.read())

            if jdata['response_code'] == 0:
                print(sha256 + " -- Not Found in VT")
                return "no"
            else:
                self.virustotal_result = jdata['positives']
                print("=== Results for SHA256: ", jdata['sha256'], "\tDetected by: ", self.virustotal_result)
                return jdata['positives']
	
	# 분석 요청
        def reqScan(filepath, sha256):
            print("- Requesting a new scan")
            param = {'file': sha256, 'apikey': api}
            url = base + "file/scan"
            data = urllib.parse.urlencode(param)  # Python 3에는 urllib가 나뉘어져 있음 (parse, request)
            data = data.encode('utf-8')  # urlopen()에 data를 넣기 위해, 인코딩이 되어 있어야 함.
            result = urllib.request.urlopen(url, data)

            jdata = json.loads(result.read())
            return jdata

        def read_file_get_sha256(file_path):
            with open(file_path, "rb") as f:
                file = f.read()
            return hashlib.sha256(file).hexdigest()

        sha256 = read_file_get_sha256(self.file_path)
        rns = get_report(sha256)  # rns는 악성코드가 백신에 탐지된 갯수를 의미함

        print("7. Virus total scan complete!!")

    # SQL 저장하기
    def save_SQL(self):
        def get_MD5(self):
            with open('Temp'+self.file_name, "rb") as f:
                f = f.read()
                return hashlib.md5(f).hexdigest()

        # SQL 연결 설정
        mydb = mysql.connector.connect(
            host="capstons-db.cuwqixyzmmdw.us-east-1.rds.amazonaws.com",
            user="admin",
            passwd="capstondb",
            database="capstondb"
        )

        # SQL Curser 설정
        cur = mydb.cursor(prepared=True)

        # FileKey Table 저장
        query = "INSERT INTO FileKey VALUES (%s, %s, %s)"
        values = (get_MD5(self), self.image_name, self.file_name)
        cur.execute(query, values)
        mydb.commit()

        # 저장 결과 확인
        print("FileKey")
        cur.execute("SELECT * FROM FileKey")
        result = cur.fetchall()
        for result in result:
           print(result)

        # FileHeader Table 저장
        query = "INSERT INTO FileHeader VALUES (%s, %s, %s, %s)"
        values = (self.pe_values[0][1], self.pe_values[0][0], get_MD5(self), self.image_name)
        cur.execute(query, values)
        mydb.commit()

        # 저장 결과 확인
        print("FileHeader")
        cur.execute("SELECT * FROM FileHeader")
        result = cur.fetchall()
        for result in result:
           print(result)

        # OptionalHeader Table 저장
        query = "INSERT INTO OptionalHeader VALUES (%s, %s, %s, %s, %s, %s, %s)"
        values = (self.pe_values[1][0], self.pe_values[1][1], self.pe_values[1][2], self.pe_values[1][3], self.pe_values[1][4], get_MD5(self), self.image_name)
        cur.execute(query, values)
        mydb.commit()

        # 저장 결과 확인
        print("OptionalHeader")
        cur.execute("SELECT * FROM OptionalHeader")
        result = cur.fetchall()
        for result in result:
            print(result)

        # SectionHeader 저장
        # SectionHeader Table 저장
        query = "INSERT INTO SectionHeader VALUES (%s, %s, %s, %s, %s, %s, %s)"
        values = (self.pe_values[2][0], self.pe_values[2][1], self.pe_values[2][2], self.pe_values[2][3], self.pe_values[2][4], get_MD5(self), self.image_name)
        cur.execute(query, values)
        mydb.commit()

        # 저장 결과 확인
        print("SectionHeader")
        cur.execute("SELECT * FROM SectionHeader")
        result = cur.fetchall()
        for result in result:
            print(result)

        print("8. Save Value in SQL complete!!")

    def main(self):
        self.PE_check()
        self.get_sha256_value()
        self.Extract_PE_Header()
        self.Extract_Image()
        self.do_CNN()
        self.VirusTotal_Scan()
        self.save_SQL()
	
	# 임시로 저장한 파일들 삭제
        os.remove('Temp'+self.file_name)
        os.remove(self.image_name + ".png")
        os.remove(self.image_name + "_thumb.png")
        self.file = b'00'
        return 0

if __name__ == "__main__":
    server = malware_analysis_server()
    while True:
        try:
            server.input_file() # 파일을 불러오기
        except:
            pass

        if server.file != b'00': # 파일이 있으면 메인 루틴을 실행
            server.main()
        print('Wait for new files...')
        time.sleep(5)